# -*- coding: utf-8 -*-
"""4.1 Adaptive Energy Optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16n1ko3aVpyU_UhZ1iWNvaqYHbZ9a1e2t
"""

# STEP 1: Install and Import Packages
!pip install scipy pandas matplotlib openpyxl

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import linprog

# STEP 2: Load Your Files (Upload in Colab)
from google.colab import files
uploaded = files.upload()

# Required files:
# - improved_prediction_JanMar2024_LSTM_v2_<timestamp>.csv
# - user_profile_clusters_separated.csv
# - export_UiS Living Lab - 2024 v1.xlsx

# STEP 3: Load Data
solar = pd.read_csv("improved_prediction_JanMar2024_LSTM_v2_20250521_195651.csv")
solar['Timestamp'] = pd.to_datetime(solar['Timestamp'])
solar.set_index("Timestamp", inplace=True)
solar_hourly = solar.resample("H").sum().reset_index().rename(columns={"Predicted (kWh)": "SolarForecast"})

profiles = pd.read_csv("user_profile_clusters_separated.csv")
profiles['Time (UTC)'] = pd.to_datetime(profiles['Time (UTC)'])

# Total hourly consumption
usage = profiles.groupby('Time (UTC)')['EnergyUsage'].sum().reset_index().rename(columns={"EnergyUsage": "TotalConsumption"})
profiles = pd.merge(profiles, usage, on="Time (UTC)")
profiles = profiles.drop_duplicates("Time (UTC)")

# Merge with solar forecast
merged = pd.merge(profiles, solar_hourly, how="inner", left_on="Time (UTC)", right_on="Timestamp")
merged = merged[(merged['Time (UTC)'] >= "2024-01-01") & (merged['Time (UTC)'] <= "2024-03-31")]

# STEP 4: Load Energy Price
raw = pd.read_excel("export_UiS Living Lab - 2024 v1.xlsx")
raw['Time (UTC)'] = pd.to_datetime(raw['Time (UTC)'].astype(str).str.replace("Z", ""), errors='coerce')
raw = raw.dropna(subset=['Time (UTC)'])
raw['Time (UTC)'] = raw['Time (UTC)'].dt.tz_localize(None)
raw.set_index("Time (UTC)", inplace=True)
hourly_price = raw[['EnergyPrice']].resample('H').mean().reset_index()

# STEP 5: Run MILP + HPOA
results = []
grid_penalty = 2
solar_waste_penalty = 1
NUM_CANDIDATES = 100

for _, row in merged.iterrows():
    t = row['Time (UTC)']
    demand = row['TotalConsumption']
    solar = max(0, row['SolarForecast'])
    profile = row['ProfileLabel']

    # MILP
    A = [[1, 1], [-1, 0], [0, -1]]
    b = [demand, -solar, 0]
    bounds = [(0, None), (0, None)]
    res = linprog(c=[0, 1], A_ub=A, b_ub=b, bounds=bounds, method='highs')
    milp_solar = res.x[0] if res.success else min(solar, demand)
    milp_grid = res.x[1] if res.success else max(0, demand - solar)

    # HPOA
    best_fitness = -np.inf
    best_solar = 0
    for _ in range(NUM_CANDIDATES):
        ratio = np.random.rand()
        solar_used = min(ratio * demand, solar)
        grid_used = max(0, demand - solar_used)
        unused_solar = max(0, solar - solar_used)
        fitness = - (grid_penalty * grid_used + solar_waste_penalty * unused_solar)
        if fitness > best_fitness:
            best_fitness = fitness
            best_solar = solar_used
    hpoa_solar = best_solar
    hpoa_grid = max(0, demand - hpoa_solar)

    results.append({
        'Time (UTC)': t,
        'TotalConsumption': demand,
        'SolarForecast': solar,
        'ProfileLabel': profile,
        'SolarUsed_MILP': milp_solar,
        'GridUsed_MILP': milp_grid,
        'SolarUsed_HPOA': hpoa_solar,
        'GridUsed_HPOA': hpoa_grid
    })

df = pd.DataFrame(results)

# STEP 6: Merge Energy Price and Suggestion Logic
hourly_price['Time (UTC)'] = pd.to_datetime(hourly_price['Time (UTC)'])
df = pd.merge(df, hourly_price, on="Time (UTC)", how="left")

df['Suggestion'] = df.apply(
    lambda row: "Shift load to this hour (high solar, low price)"
    if row['SolarForecast'] > 1 and row['EnergyPrice'] < 50 else "No shift recommended",
    axis=1
)

# STEP 7: Save & Display Results
df.to_csv("final_optimized_with_price_and_suggestions.csv", index=False)

# Summary Table
summary = df.groupby("ProfileLabel")[[
    "TotalConsumption", "SolarUsed_MILP", "GridUsed_MILP", "SolarUsed_HPOA", "GridUsed_HPOA"
]].sum()
summary["SolarRatio_MILP"] = summary["SolarUsed_MILP"] / summary["TotalConsumption"]
summary["SolarRatio_HPOA"] = summary["SolarUsed_HPOA"] / summary["TotalConsumption"]
summary = summary.round(2)
print(summary)

# Plot daily solar usage
df['Date'] = pd.to_datetime(df['Time (UTC)']).dt.date
daily = df.groupby(['Date', 'ProfileLabel'])[
    ['SolarUsed_MILP', 'SolarUsed_HPOA']
].sum().reset_index()

plt.figure(figsize=(14,6))
for profile in df['ProfileLabel'].unique():
    sub = daily[daily['ProfileLabel'] == profile]
    plt.plot(sub['Date'], sub['SolarUsed_MILP'], label=f"{profile} - MILP")
    plt.plot(sub['Date'], sub['SolarUsed_HPOA'], linestyle='--', label=f"{profile} - HPOA")
plt.title("Daily Solar Usage by Profile (MILP vs HPOA)")
plt.xlabel("Date")
plt.ylabel("kWh")
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()